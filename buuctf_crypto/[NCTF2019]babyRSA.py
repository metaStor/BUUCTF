from Crypto.Util.number import *
import gmpy2
import sympy
# from flag import flag


'''
def nextPrime(n):
    n += 2 if n & 1 else 1
    while not isPrime(n):
        n += 2
    return n

p = getPrime(1024)
q = nextPrime(p)
n = p * q
e = 0x10001
d = inverse(e, (p-1) * (q-1))
c = pow(bytes_to_long(flag.encode()), e, n)

# d = 19275778946037899718035455438175509175723911466127462154506916564101519923603308900331427601983476886255849200332374081996442976307058597390881168155862238533018621944733299208108185814179466844504468163200369996564265921022888670062554504758512453217434777820468049494313818291727050400752551716550403647148197148884408264686846693842118387217753516963449753809860354047619256787869400297858568139700396567519469825398575103885487624463424429913017729585620877168171603444111464692841379661112075123399343270610272287865200880398193573260848268633461983435015031227070217852728240847398084414687146397303110709214913
# c = 5382723168073828110696168558294206681757991149022777821127563301413483223874527233300721180839298617076705685041174247415826157096583055069337393987892262764211225227035880754417457056723909135525244957935906902665679777101130111392780237502928656225705262431431953003520093932924375902111280077255205118217436744112064069429678632923259898627997145803892753989255615273140300021040654505901442787810653626524305706316663169341797205752938755590056568986738227803487467274114398257187962140796551136220532809687606867385639367743705527511680719955380746377631156468689844150878381460560990755652899449340045313521804
'''

d = 19275778946037899718035455438175509175723911466127462154506916564101519923603308900331427601983476886255849200332374081996442976307058597390881168155862238533018621944733299208108185814179466844504468163200369996564265921022888670062554504758512453217434777820468049494313818291727050400752551716550403647148197148884408264686846693842118387217753516963449753809860354047619256787869400297858568139700396567519469825398575103885487624463424429913017729585620877168171603444111464692841379661112075123399343270610272287865200880398193573260848268633461983435015031227070217852728240847398084414687146397303110709214913
c = 5382723168073828110696168558294206681757991149022777821127563301413483223874527233300721180839298617076705685041174247415826157096583055069337393987892262764211225227035880754417457056723909135525244957935906902665679777101130111392780237502928656225705262431431953003520093932924375902111280077255205118217436744112064069429678632923259898627997145803892753989255615273140300021040654505901442787810653626524305706316663169341797205752938755590056568986738227803487467274114398257187962140796551136220532809687606867385639367743705527511680719955380746377631156468689844150878381460560990755652899449340045313521804
e = 0x10001
e = int(e)

# 已知d,c,e，可通过 e * d = 1 mod phi(n) 求得欧拉函数phi
# e * d = k * phi(n) + 1  ====>>  k * phi(n) = (e * d - 1)
# 其中，k的范围为: (0, e*d-1]
# print(len(str(bin(e*d-1))))  # 用bin转为二进制长度为2066位
# 查看p,q的生成方法，p的范围在1024位，q的范围在n附近也是1024左右
# 那么n、phi(n)的范围就在2048位左右
# 综上，则k的范围为：2066-2048=18位，也是20位以内
for k in range(pow(2, 10), pow(2, 20)):
    if (e * d - 1) % k == 0:
        phi = (e * d - 1) // k
        p = sympy.prevprime(gmpy2.iroot(phi, 2)[0])  # 得到给定数字n的前一个素数 (n<2^64)
        q = sympy.nextprime(p)
        if (p - 1) * (q - 1) == phi:
            print(f"get p,q:\np = {p}\nq = {q}")
            n = p * q
            m = gmpy2.powmod(c, d, n)
            print(long_to_bytes(m))
            break
