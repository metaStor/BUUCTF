import gmpy2
from sympy import *
from Crypto.Util.number import *

# 第一部分
# hint.py 的内容，给了c1,c2 e1,c2 n；明显是共模攻击
n = 6807492006219935335233722232024809784434293293172317282814978688931711423939629682224374870233587969960713638310068784415474535033780772766171320461281579
e1 = 2303413961
c1 = 1754421169036191391717309256938035960912941109206872374826444526733030696056821731708193270151759843780894750696642659795452787547355043345348714129217723
e2 = 2622163991
c2 = 1613454015951555289711148366977297613624544025937559371784736059448454437652633847111272619248126613500028992813732842041018588707201458398726700828844249

# 共模攻击, m = c1^s1 * c2^s2 mod n
_, s1, s2 = gmpy2.gcdext(e1, e2)
# 求得 hint 的密文 c
hint_c = (pow(c1, s1, n) * pow(c2, s2, n)) % n

hint_e = 256
hint_n = 107316975771284342108362954945096489708900302633734520943905283655283318535709
# hint_n 为质数，涉及到二次剩余问题
# Find the solutions to x**n = a mod p
m = nthroot_mod(hint_c, hint_e, hint_n, all_roots=False)  # all_roots 如果为 True 则返回根列表或 None
print(long_to_bytes(m))  # b'm.bit_length() < 400'


# 第二部分
# task.py的内容, 给了n、c1、c2，e1, e2 = p, q
n = 128205304743751985889679351195836799434324346996129753896234917982647254577214018524580290192396070591032007818847697193260130051396080104704981594190602854241936777324431673564677900773992273463534717009587530152480725448774018550562603894883079711995434332008363470321069097619786793617099517770260029108149
c1 = 96860654235275202217368130195089839608037558388884522737500611121271571335123981588807994043800468529002147570655597610639680977780779494880330669466389788497046710319213376228391138021976388925171307760030058456934898771589435836261317283743951614505136840364638706914424433566782044926111639955612412134198
c2 = 9566853166416448316408476072940703716510748416699965603380497338943730666656667456274146023583837768495637484138572090891246105018219222267465595710692705776272469703739932909158740030049375350999465338363044226512016686534246611049299981674236577960786526527933966681954486377462298197949323271904405241585
'''
由题意：
c1 = m^p mod p*q ①
c2 = m^q mod p*q
费马小定理：假如a是一个整数，p是一个质数，那么a^p-a是p的倍数 ==> a^p ≡ a (mod p)
且题的p、q均为质数，则由费马小定理有：
m^p ≡ m mod p ②
m^q ≡ m mod q
联立 ①②有：
c1 = m mod p  ==>  c1 = k1*p + m
c2 = m mod q  ==>  c2 = k2*q + m
因此:
c1 * c2 = (k1*p + m) * (k2*q + m) = m^2 + (k1*p + k2*q)*m + k1*k2*n ①
c1 + c2 = (k1*p + m) + (k2*q + m) = 2*m + (k1*p + k2*q), 两边同时乘以m:
m*(c1+c2) = 2*m^2 + (k1*p + k2*q)*m  ②
②-①得：
m*(c1+c2) - c1*c2 = m^2 - k1*k2*n
m*(c1+c2) - c1*c2 = m^2 mod n
解方程解出m即可

由于hint提示了m有长度小于400限制，所以联想到Coppersmith定理。(https://ctf-wiki.org/crypto/asymmetric/rsa/rsa_coppersmith_attack/)
Coppersmith定理的内容为：在一个e阶的mod n多项式f(x)中，如果有一个根小于n^1/e，就可以运用一个O(log n)的算法求出这些根。
计算可得m是满足这个情况的
'''
# sage语言脚本，在线运行：https://sagecell.sagemath.org/
'''
n = 128205304743751985889679351195836799434324346996129753896234917982647254577214018524580290192396070591032007818847697193260130051396080104704981594190602854241936777324431673564677900773992273463534717009587530152480725448774018550562603894883079711995434332008363470321069097619786793617099517770260029108149
c1 = 96860654235275202217368130195089839608037558388884522737500611121271571335123981588807994043800468529002147570655597610639680977780779494880330669466389788497046710319213376228391138021976388925171307760030058456934898771589435836261317283743951614505136840364638706914424433566782044926111639955612412134198
c2 = 9566853166416448316408476072940703716510748416699965603380497338943730666656667456274146023583837768495637484138572090891246105018219222267465595710692705776272469703739932909158740030049375350999465338363044226512016686534246611049299981674236577960786526527933966681954486377462298197949323271904405241585

PR.<x> = PolynomialRing(Zmod(n))
# R.<x> = PolynomialRing(Zmod(n),implementation = 'NTL')
# R.<x> = Zmod(n)[]
# 上面三个都行
fn = x^2 - x*(c1+c2) + c1*c2
flag = fn.small_roots(X=2^400) # 2 ^ 400是根的上界
print(flag)
'''
flag = 4242839043019782000788118887372132807371568279472499477998758466224002905442227156537788110520335652385855
print(long_to_bytes(flag))
