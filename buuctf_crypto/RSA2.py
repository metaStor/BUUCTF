'''
公式推导：https://blog.csdn.net/MikeCoke/article/details/106095234

已知e、n、dp、密文c，求明文m。
首先要求d => d = gmpy2.invert(e, phi_n)
一、需要条件:
① dp = d mod (p-1)
② m = c^d mod n
③ e * d = 1 mod phi(n)
④ phi(n) = (p-1)*(q-1)

二、推导:
由 dp ≡ d mod (p-1)
==> dp * e = e * d mod (p-1)
==> e * d = dp * e + k1(p-1) ，k1 ∈ Z（正整数） ⑤ 【 比如， 7%5=2 可推导为 7=5*k1+2】
由 ③ e * d = 1 mod phi(n)
==> e * d = 1 mod (p-1)(q-1)
==> e * d = 1 + k2(p-1)(q-1) , k2 ∈ 整数 ⑥ 【 比如， 7%5=2 可推导为 2=5*k2+7，（k2=-1）】
由 ⑤⑥ 得：
==> dp * e + k1(p-1) = 1 + k2(p-1)(q-1)
==> dp * e = 1 + (p-1)(k2(q-1)-k1), k1 ∈ Z（正整数）, k2 ∈ 整数
令 x = (k2(q-1)-k1), 得:
==> dp * e = 1 + (p-1) * x  ⑦
由 ① 可知: dp < (p-1), 且由 ⑦ 可得 e 与 x 的大小关系:
==> e >= x
==> x ∈ (1, e]  ⑧
由 ⑧ 可通过遍历出 x，使得满足 ⑦，由于dp、e已知，可通过 x 求出 (p-1)，且 n 已知，可求出 q, p和q求出phi，phi求出d即可。
'''

import gmpy2

e = 65537
n = 248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113
dp = 905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657
c = 140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751
for i in range(1, e):
    if (dp * e - 1) % i == 0:
        if (n % ((dp * e - 1) // i + 1)) == 0:
            p = (dp * e - 1) // i + 1
            q = n // p  # 注意都是整除
            phi_n = (p - 1) * (q - 1)
            d = gmpy2.invert(e, phi_n)
            m = pow(c, d, n)

print(bytes.fromhex(hex(m)[2:]).decode())
